# 正则表达式：用一种描述性的语言来给字符串定义一个规则
# \d(匹配一个数字)，\w(匹配一个字母或数字)，.(匹配任意字符)，\s(匹配一个空格)
# *(表示任意个字符)，+(表示至少一个字符)，?(表示0个或1个字符)，{n}(表示n个字符)，{n,m}(表示n到m个字符)
# \d{3}\s+\d{3,8}\_ 
# \d{3}表示匹配3个数字，\s+表示至少有一个空格，\d{3,8}表示匹配3到8个数字,'\'转义,\_相当于一个下划线
# A|B(可以匹配A或B)，^(表示行的开头)，^\d(表示必须以数字开头)，$(表示行的结束)，\d$(表示必须以数字结束)
# (P|p)ython
# 可以匹配'Python'或者'python'
# ^py$
# 只能匹配py

# re模块
# re.match() 匹配成功，返回一个match对象，匹配失败，返回空
import re
# <_sre.SRE_Match object; span=(0, 9), match='010-12345'>
print(re.match(r'^\d{3}\-\d{3,8}$', '010-12345'))
# 用正则来切割字符串
print(re.split(r'\s+', 'a b   c')) # 正则匹配至少一个空格
print(re.split(r'[\s\,]+', 'a,b, c  d')) # 正则匹配至少一个空格和逗号
print(re.split(r'[\s\,\;]+', 'a,b;; c  d'))
# 用()来表示分组，如果有分组，可以用group()来提取
x = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print(x)
print(x.group(2))
# 正则表达式默认的是贪婪匹配，会匹配上符合条件的所有东西，加上问号(?)会解除贪婪匹配
print(re.match(r'^(\d+)(0*)$', '102300').groups())   # ('102300', '')
print(re.match(r'^(\d+?)(0*)$', '102300').groups())  # ('1023', '00')
# re.compile() 表示预编译，将正则表达式提前编译好，然后直接使用，常用于多次使用的正则
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
print(re_telephone.match('010-12345').groups())  # ('010', '12345')
