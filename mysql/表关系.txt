# 关系
1. 一对一

    自己的一个对象，对应对方的一个对象
    比如人，和身份证，就是一对一的关系
    这时候，可以互相镶嵌，两种都可以。

    个人
    id    name    height   weight   location
    1     张三    180cm    60kg     陕西

    身份证
    id    issued_time  generation  issuer
    1      2010年        2代        西安市公安局

    这个时候，可以把 身份证 id 加到个人里面，也可以把个人加到身份证里面
    个人
    id    name    height   weight   location card_id
    1     张三     180cm       60kg  陕西     1
    这样就可以通过个人找到身份证信息，也可以通过身份证找到个人信息。
    或者，反过来

    身份证
    id    issued_time  generation  issuer         user_id
    1      2010年        2代        西安市公安局    1
    这样也可以达到同样目的。


2. 一对多
    自己的一个对象，对应对方的多个对象
    比如个人，和衣服，一个人可以有多个衣服，一个衣服只能属于一个人
    那么，个人表和上面一样。
    cloth
    id      create_time   price   color   season   style
    1       2010年         200元  红色     夏季     韩国风格

    这个时候，要建立关系，就必须把个人嵌入到衣服表里。也就是说，“一”嵌入到“多”的表里。
    反过来就不对了。

    cloth
    id      create_time   price   color   season   style     user_id
    1       2010年         200元  红色     夏季     韩国风格   1
    这是可以的。
    反过来的话
    个人
    id    name    height   weight   location   cloth_ids
    1     张三     180cm   60kg     陕西       1,2,3,4,5
    一个人好几件衣服，这样就不对了。


3. 多对一
    和一对多类似，同样是“一”嵌入到“多”的表里
    比如个人和上面一样。
    公司，一个人属于一个公司，一个公司可以有多个人。

    company
    id      name   location   create_time    employees
    1       a公司   西安       2010年         200员工
    2       b公司   西安       2012年         100个员工
    这时候建立关系，就必须把公司 id 嵌入到个人里面，反过来不对。


    个人
    id    name    height   weight   location company_id
    1     张三     180cm       60kg  陕西      1
    这样才对



4. 多对多
    一个人可以有多个老师，一个老师也可以有多个学生
    个人表和上面一样
    这个时候，都是“多”，就不能嵌入了。只能新加一个关系表。

    teacher
    id     name    birth    object    experiences
    1      王老师  1970年    语文       10年经验



    teacher_student
    id  teacher_id  student_id
    1    1             1
    2    1             2
    3    1             3
    4    2             1
    5    2             2

    可以看到，1号老师，教了1，2，3三个学生。同样的，1好学生也被2号老师教。


最后看一个例子：
    qq的好友关系
    一人一个qq号，可以互相加好友，这是多对多的关系，而且是自己对自己的关系
    个人
    id   qq    name   birth    age
    1    22222  张三   2001年  20


    friends
    id    from_id    to_id
    1      1          2
    2      2          1
    3      1          3
    4      3          1


    1号和2号是好友，1号和3号也是好友。
    这里看起来重复了，1 2 和 2 1 其实是一回事。
    不重复的放
    friends
    id   from_id   to_id
    1      1        2
    2      1        3
    3      1        10010
    ...
    10001  10001    10010

    这是不重复的放，
    但是，qq 的人很多，比如from_id 1到1万号放一个服务器，1万到2万放一个服务器。
    我想查10010号的好友有谁，就不好查了，第一个服务器上有，第二个服务器还有，要查好几次才行。

    所以要不要重复放，要看实际情况。
    还有一种情况是，关系不是对称的，比如说，单向好友，微博，你关注了这个人，不等于这个人关注了你。
    和好友就不一样了。这个时候，就需要再加一个表。
    比如说，微博，可以看我关注了谁，也可以看谁关注了我。



    依赖有两种，一种是弱的依赖，比如说，优惠券依赖订单，只有在使用的时候，平时呢，不依赖。没有订单，也可以有优惠券。
    但是呢，优惠券依赖用户，这个是强依赖，用户没有了，优惠券不能单独存在。这里就需要数据库处理了，你在创建数据库的时候会写。
    owner = ForeignKeyField(Users, related_name='owner_UC', on_delete='CASCADE')
    on_delete='CASCADE',这个意思就是，当你依赖的那个表，删除的时候，你怎么办。
    你比如说，优惠券1属于用户1，那么，我删除用户1的时候，优惠券1怎么办,
    有三种情况，第一种 cascade，瀑布的意思，也就是说，级联删除,删用户，
    同时把属于他的优惠券也给删除了,还有一种，set null，设置为空，也就是说，删除用户，我不删优惠券，把优惠券的属于那个人设置为空,
    第三，no action，没动作，也就是说，你删用户，我优惠券不变,这个具体用哪个，看实际的情况，你们这里用的 cascade
    情况变了，也可以选用其他两个,除了 on delete，还有一个，on update,
    优惠券1属于用户1，这个时候，用户1id变成2了，优惠券1的 user_id 要不要跟着变,也是这三种，要么跟着变，要么设置为null，要么不动